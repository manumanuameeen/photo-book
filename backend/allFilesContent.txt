

==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\app.ts ====



==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\config\db.ts ====

Ôªøimport mongoose from "mongoose";

export const connectDB = async (): Promise<void> => {
  try {
    const uri = process.env.MONGO_URI || "";
    if (!uri) throw new Error("MongoDB URI missing in environment variables");

    await mongoose.connect(uri, {
      dbName: "photoBookDB",
    });
    console.log("‚úÖ MongoDB connected successfully");
    console.log("üìÇ Database:", mongoose.connection.db?.databaseName);
  } catch (error: any) {
    console.error("‚ùå MongoDB connection failed:", error.message);
    process.exit(1);
  }
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\config\email.ts ====

import nodemailer from "nodemailer";

export const mailTransport = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\config\logger.ts ====

import { createLogger, format, transports } from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import fs from "fs";
import path from "path";

const logDir = "logs";
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir);
}

const { combine, timestamp, printf, errors, colorize, json } = format;

const logFormat = printf(({ level, message, timestamp, stack, ...meta }) => {
  const metaString = Object.keys(meta).length ? JSON.stringify(meta, null, 2) : "";
  return `${timestamp} [${level}]: ${stack || message} ${metaString}`;
});

const errorRotateTransport = new DailyRotateFile({
  filename: path.join(logDir, "error-%DATE%.log"),
  datePattern: "YYYY-MM-DD",
  level: "error",
  maxSize: "20m",
  maxFiles: "14d",
  format: combine(timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), errors({ stack: true }), json()),
});

const combinedRotateTransport = new DailyRotateFile({
  filename: path.join(logDir, "combined-%DATE%.log"),
  datePattern: "YYYY-MM-DD",
  maxSize: "20m",
  maxFiles: "30d",
  format: combine(timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), errors({ stack: true }), json()),
});

const httpRotateTransport = new DailyRotateFile({
  filename: path.join(logDir, "http-%DATE%.log"),
  datePattern: "YYYY-MM-DD",
  maxSize: "20m",
  maxFiles: "7d",
  format: combine(timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), json()),
});

const logger = createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: combine(timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), errors({ stack: true }), logFormat),
  transports: [errorRotateTransport, combinedRotateTransport, httpRotateTransport],
  exceptionHandlers: [
    new DailyRotateFile({
      filename: path.join(logDir, "exceptions-%DATE%.log"),
      datePattern: "YYYY-MM-DD",
      maxSize: "20m",
      maxFiles: "30d",
    }),
  ],
  rejectionHandlers: [
    new DailyRotateFile({
      filename: path.join(logDir, "rejections-%DATE%.log"),
      datePattern: "YYYY-MM-DD",
      maxSize: "20m",
      maxFiles: "30d",
    }),
  ],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new transports.Console({
      format: combine(colorize(), timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), logFormat),
    }),
  );
}

export const httpLogStream = {
  write: (message: string) => {
    logger.http(message.trim());
  },
};

export default logger;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\config\redis.ts ====

import { createClient } from "redis";
import dotenv from "dotenv";
dotenv.config();

const redisClient = createClient({
  url: process.env.REDIS_URL,
});

redisClient.on("connect", () => console.log("‚úÖ Redis connected successfully"));
redisClient.on("error", (err: Error) => console.error("‚ùå Redis connection error:", err));

redisClient.connect();

export default redisClient;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\config\swagger.ts ====

import swaggerJsdoc from "swagger-jsdoc";

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "PhotoBook API",
      version: "1.0.0",
      description: "PhotoBook API Documentation",
    },
    servers: [
      {
        url: "http://localhost:5000",
        description: "Development server",
      },
    ],
    components: {
      securitySchemes: {
        cookieAuth: {
          type: "apiKey",
          in: "cookie",
          name: "accessToken",
        },
      },
    },
  },
  apis: ["./src/routes/*.ts"],
};

export const swaggerSpec = swaggerJsdoc(options);


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\constants\env.ts ====

export const ENV = {
  ACCESS_TOKEN_MAX_AGE: Number(process.env.ACCESS_TOKEN_MAX_AGE) || 15 * 60 * 1000,
  REFRESH_TOKEN_MAX_AGE: Number(process.env.REFRESH_TOKEN_MAX_AGE) || 7 * 24 * 60 * 60 * 1000,
} as const;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\constants\httpStatus.ts ====

export const HttpStatus = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  INTERNAL_SERVER_ERROR: 500,
} as const;

export type HttpStatus = (typeof HttpStatus)[keyof typeof HttpStatus];


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\constants\messages.ts ====

export const Messages = {
  SUCCESS: "Success",
  OTP_SENT: "OTP sent to email",
  OTP_VERIFIED: "OTP verified successfully",
  LOGIN_SUCCESS: "Login successful",
  LOGOUT_SUCCESS: "Logged out successfully",
  USER_BLOCKED: "User is blocked",
  USER_NOTFOUND: "User Not found",
  INVALID_CREDENTIALS: "Invalid email or password",
  INVALID_OTP: "Invalid or expired OTP",
  USER_EXISTS: "User already exists",
  REFRESH_TOKEN_MISSING: "Refresh token missing",
  INVALID_REFRESH_TOKEN: "Invalid refresh token",
  INTERNAL_ERROR: "Internal server error",
  FORGET_PASSWORD_SENT: "Reset code sent to your email",
  RESET_OTP_VERIFIED: "Code verified. Set new password.",
  PASSWORD_RESET_SUCCESS: "Password reset successful!",
  INVALID_RESET_OTP: "Invalid or expired code",
  VERIFY_FIRST: "Verify code first",
  PASSWORDS_DONT_MATCH: "Passwords do not match",
  NO_TOKEN_PROVIDED: "no token provided",
  TOKEN_INVALID: "Token has been invalidated. Please login again.",
} as const;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\constants\routes.ts ====

export const ROUTES = {
  V1: {
    AUTH: {
      BASE: "/api/v1/auth",
      SIGNUP: "/signup",
      VERIFY_OTP: "/verify-otp",
      RESEND_OTP: "/resend-otp",
      LOGIN: "/login",
      REFRESH: "/refresh-token",
      LOGOUT: "/logout",
      FORGOT_PASSWORD: "/forget-password",
      VERIFY_RESET_OTP: "/verify-reset-otp",
      RESET_PASSWORD: "/reset-password",
    },
    USER: {},
    ADMIN: {
      BASE: "/api/v1/admin",
      USERS: "/users",
      USER_BY_ID: "/users/:id",
      BLOCK: "/users/:id/block",
      UNBLOCK: "/users/:id/unblock",
    },
  },
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\controller\adminUser.controller.ts ====

import type { Request, Response } from "express";
import type { IAdminService } from "../services/admin/interface/IAdminService.ts";
import type { IAdminController } from "../interfaces/admin/IAdminController.ts";
import { z } from "zod";
import { AdminUserQueryDto } from "../dto/admin.dto.ts";
import { AdminMapper } from "../mappers/admin.mapper.ts";

export class AdminController implements IAdminController {
  private adminService: IAdminService;

  constructor(adminService: IAdminService) {
    this.adminService = adminService;
  }

  private _validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
    return schema.parse(data);
  }

  getAllUser = async (req: Request, res: Response): Promise<void> => {
    try {
      const queryDto = this._validate(AdminUserQueryDto, req.query);

      const queryInput = AdminMapper.toQueryInput(queryDto);
      const result = await this.adminService.getAllUser(queryInput);
      // console.log("result. fro mcontroller:", result)
      res.status(200).json({
        success: true,
        message: "Users fetched successfully",
        data: {
          users: result.users.map(AdminMapper.toUserResponse),
          pagination: {
            total: result.total,
            totalPages: result.totalPages,
            currentPage: result.currentPage,
          },
        },
      });
    } catch (error: any) {
      console.error(" CONTROLLER ERROR:", error);
      res.status(500).json({
        success: false,
        message: error.message || "Internal server error",
      });
    }
  };

  getUser = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const user = await this.adminService.getUser(id);

      if (!user) {
        res.status(404).json({
          success: false,
          message: "User not found",
        });
        return;
      }

      res.status(200).json({
        success: true,
        message: "User fetched successfully",
        data: user,
      });
    } catch (error: any) {
      console.error("Error fetching user:", error);
      res.status(500).json({
        success: false,
        message: error.message || "Internal server error",
      });
    }
  };

  blockUser = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const user = await this.adminService.blockUser(id);

      res.status(200).json({
        success: true,
        message: "User blocked successfully",
        data: user,
      });
    } catch (error: any) {
      console.error("Error blocking user:", error);
      res.status(500).json({
        success: false,
        message: error.message || "Internal server error",
      });
    }
  };

  unblockUser = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const user = await this.adminService.unblockUser(id);

      res.status(200).json({
        success: true,
        message: "User unblocked successfully",
        data: user,
      });
    } catch (error: any) {
      console.error("Error unblocking user:", error);
      res.status(500).json({
        success: false,
        message: error.message || "Internal server error",
      });
    }
  };
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\controller\auth.controller.ts ====

import type { Request, Response } from "express";
import { z } from "zod";
import type { IAuthController } from "../interfaces/user/IauthController.ts";
import type { IAuthService } from "../services/user/auth/IAuthService.ts";
import {
  ForgetPasswordDto,
  LoginDto,
  ResendOtpDto,
  ResetPasswordDto,
  SignupDto,
  VerifyOtpDto,
  VerifyResetOtpDto,
} from "../dto/auth.dto.ts";
import { ApiResponse } from "../utils/response.ts";
import { HttpStatus } from "../constants/httpStatus.ts";
import { Messages } from "../constants/messages.ts";
import { ENV } from "../constants/env.ts";
import { AppError } from "../utils/AppError.ts";
import { UserMapper } from "../mappers/user.mapper.ts";

export class AuthController implements IAuthController {
  private readonly _authService: IAuthService;

  constructor(authService: IAuthService) {
    this._authService = authService;
  }

  private _validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
    return schema.parse(data);
  }

  signup = async (req: Request, res: Response): Promise<void> => {
    try {
      const input = this._validate(SignupDto, req.body);
      const result = await this._authService.signup(input);
      ApiResponse.success(
        res,
        { user: { email: input.email, name: input.name } },
        result.message,
        HttpStatus.CREATED,
      );
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  verifyOtp = async (req: Request, res: Response): Promise<void> => {
    try {
      const input = this._validate(VerifyOtpDto, req.body);
      const result = await this._authService.verifyOtp(input);
      this._setCookies(res, result.accessToken, result.refreshToken);
      ApiResponse.success(
        res,
        {
          user: UserMapper.toAuthResponse(result.user),
        },
        Messages.OTP_VERIFIED,
      );
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  resendOtp = async (req: Request, res: Response): Promise<void> => {
    try {
      const input = this._validate(ResendOtpDto, req.body);
      const result = await this._authService.resendOtp(input);
      ApiResponse.success(res, null, result.message);
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  login = async (req: Request, res: Response): Promise<void> => {
    try {
      console.log("login contoller", req);
      const input = this._validate(LoginDto, req.body);
      const result = await this._authService.login(input);
      this._setCookies(res, result.accessToken, result.refreshToken);
      ApiResponse.success(
        res,
        {
          user: UserMapper.toAuthResponse(result.user),
        },
        Messages.LOGIN_SUCCESS,
      );
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  refresh = async (req: Request, res: Response): Promise<void> => {
    try {
      const refreshToken = req.cookies.refreshToken;
      if (!refreshToken) {
        throw new AppError(Messages.REFRESH_TOKEN_MISSING, HttpStatus.UNAUTHORIZED);
      }
      const result = await this._authService.refresh(refreshToken);
      this._setCookies(res, result.accessToken, result.refreshToken);
      ApiResponse.success(res, { user: UserMapper.toAuthResponse(result.user) });
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  logout = async (req: Request, res: Response): Promise<void> => {
    try {
      const refreshToken = req.cookies.refreshToken;
      if (refreshToken) await this._authService.logout(refreshToken);
      res.clearCookie("accessToken").clearCookie("refreshToken");
      ApiResponse.success(res, null, Messages.LOGOUT_SUCCESS);
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  forgetpassword = async (req: Request, res: Response): Promise<void> => {
    try {
      const input = this._validate(ForgetPasswordDto, req.body);
      const result = await this._authService.forgetPassword(input);
      ApiResponse.success(res, null, result.message);
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  verifyResetOtp = async (req: Request, res: Response): Promise<void> => {
    try {
      console.log("reached");
      const input = this._validate(VerifyResetOtpDto, req.body);
      const result = await this._authService.verifyResetOtp(input);
      ApiResponse.success(res, null, result.message);
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  resetPassword = async (req: Request, res: Response): Promise<void> => {
    try {
      const input = this._validate(ResetPasswordDto, req.body);
      const result = await this._authService.resetPassword(input);
      ApiResponse.success(res, null, result.message);
    } catch (error: unknown) {
      this._handleError(res, error);
    }
  };

  private _handleError(res: Response, error: unknown): void {
    if (error instanceof z.ZodError) {
      ApiResponse.error(res, "Validation failed", HttpStatus.BAD_REQUEST);
      return;
    }

    if (error instanceof AppError) {
      ApiResponse.error(res, error.message, error.statusCode as HttpStatus);
      return;
    }

    if (error instanceof Error) {
      const status = error.message.includes("blocked")
        ? HttpStatus.FORBIDDEN
        : error.message.includes("exists")
          ? HttpStatus.CONFLICT
          : HttpStatus.BAD_REQUEST;
      ApiResponse.error(res, error.message, status);
      return;
    }

    ApiResponse.error(res, Messages.INTERNAL_ERROR);
  }

  private _setCookies(res: Response, access: string, refresh: string): void {
    const isProd = process.env.NODE_ENV === "production";
    res.cookie("accessToken", access, {
      httpOnly: true,
      secure: isProd,
      sameSite: "lax",
      maxAge: ENV.ACCESS_TOKEN_MAX_AGE,
    });
    res.cookie("refreshToken", refresh, {
      httpOnly: true,
      secure: isProd,
      sameSite: "lax",
      maxAge: ENV.REFRESH_TOKEN_MAX_AGE,
    });
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\di\container.ts ====

import { UserRepository } from "../repositories/implementaion/user/user.repositery.ts";
import { AdminRepository } from "../repositories/implementaion/admin/admin.repository.ts";
import { AuthService } from "../services/user/auth/auth.servise.ts";
import { AdminServices } from "../services/admin/implementaion/admin.service.ts";
import { NodeMailerService } from "../services/user/email/nodemailer.service.ts";
import { Otpservice } from "../services/user/otp/otp.service.ts";
import { TokenBlacklistService } from "../services/token/tokenBalcklist.service.ts";
import { AuthController } from "../controller/auth.controller.ts";
import { AdminController } from "../controller/adminUser.controller.ts";


class DIContainer {
  // Repositories (Singleton)
  private _userRepository?: UserRepository;
  private _adminRepository?: AdminRepository;

  // Services (Singleton)
  private _emailService?: NodeMailerService;
  private _otpService?: Otpservice;

  private _tokenBlacklistService?: TokenBlacklistService;
  private _authService?: AuthService;
  private _adminService?: AdminServices;

  // Controllers (Singleton)
  private _authController?: AuthController;
  private _adminController?: AdminController;

  // Repositories
  get userRepository(): UserRepository {
    if (!this._userRepository) {
      this._userRepository = new UserRepository();
    }
    return this._userRepository;
  }

  get adminRepository(): AdminRepository {
    if (!this._adminRepository) {
      this._adminRepository = new AdminRepository();
    }
    return this._adminRepository;
  }

  // Services
  get emailService(): NodeMailerService {
    if (!this._emailService) {
      this._emailService = new NodeMailerService();
    }
    return this._emailService;
  }

  get otpService(): Otpservice {
    if (!this._otpService) {
      this._otpService = new Otpservice();
    }
    return this._otpService;
  }

 

  get tokenBlacklistService(): TokenBlacklistService {
    if (!this._tokenBlacklistService) {
      this._tokenBlacklistService = new TokenBlacklistService();
    }
    return this._tokenBlacklistService;
  }

  get authService(): AuthService {
    if (!this._authService) {
      this._authService = new AuthService(
        this.userRepository,
        this.emailService,
        this.otpService
      );
    }
    return this._authService;
  }

  get adminService(): AdminServices {
    if (!this._adminService) {
      this._adminService = new AdminServices(this.adminRepository);
    }
    return this._adminService;
  }

  // Controllers
  get authController(): AuthController {
    if (!this._authController) {
      this._authController = new AuthController(this.authService);
    }
    return this._authController;
  }

  get adminController(): AdminController {
    if (!this._adminController) {
      this._adminController = new AdminController(this.adminService);
    }
    return this._adminController;
  }
}

export const container = new DIContainer();

==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\dto\admin.dto.ts ====

import { z } from "zod";

export const AdminUserQueryDto = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(15).default(10),
  sort: z.string().default("createdAt"),
  search: z.string().optional().default(""),
});

export type AdminUserQueryDtoType = z.infer<typeof AdminUserQueryDto>;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\dto\auth.dto.ts ====

import { string, z } from "zod";
import { Messages } from "../constants/messages.ts";

export const SignupDto = z.object({
  name: z.string().min(2).trim(),
  email: z.string().email().toLowerCase(),
  password: z.string().min(8),
  phone: z.string().regex(/^\d{10}$/),
});

export const LoginDto = z.object({
  email: z.string().email(),
  password: z.string(),
});

export const VerifyOtpDto = z.object({
  email: z.string().email(),
  otp: z.string().length(6),
});

export const ResendOtpDto = z.object({
  email: z.string().email(),
});

export const RefreshTokenDto = z.object({
  refreshToken: z.string().min(1, "Refresh token is required"),
});

export const ForgetPasswordDto = z.object({
  email: z.string().email().trim().toLowerCase(),
});

export const VerifyResetOtpDto = z.object({
  email: z.string().email().toLowerCase(),
  otp: z.string().length(6),
});

export const ResetPasswordDto = z
  .object({
    email: z.string().email().toLowerCase(),
    newPassword: string().min(8),
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: Messages.PASSWORDS_DONT_MATCH,
    path: ["confirmPassword"],
  });

export type SignupDtoType = z.infer<typeof SignupDto>;
export type LoginDtoType = z.infer<typeof LoginDto>;
export type VerifyOtpDtoType = z.infer<typeof VerifyOtpDto>;
export type ResendOtpDtoType = z.infer<typeof ResendOtpDto>;
export type RefreshTokenDtoType = z.infer<typeof RefreshTokenDto>;
export type ForgetPasswordDtoType = z.infer<typeof ForgetPasswordDto>;
export type VerifyResetOtpDtoType = z.infer<typeof VerifyResetOtpDto>;
export type ResetPasswordDtoType = z.infer<typeof ResetPasswordDto>;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\dto\user.dto.ts ====

import { z } from "zod";

export const UpdateProfileDto = z.object({
  name: z.string().min(2).trim().optional(),
  phone: z
    .string()
    .regex(/^\d{10}$/)
    .optional(),
});

export const ChangePasswordDto = z
  .object({
    currentPassword: z.string().min(8),
    newPassword: z.string().min(8),
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Password do not match",
    path: ["confirmPassword"],
  });

export class UserResponseDto {
  id!: string;
  name!: string;
  email!: string;
  phone!: string;
  role!: string;
  walletBalance!: number;
  isBlocked!: boolean;
  createdAt!: Date;
}

export class AuthResponseDto {
  user!: {
    id: string;
    name: string;
    email: string;
    role: string;
  };
}

export class UserProfileResponseDto {
  name!: string;
  email!: string;
  phone!: string;
  role!: string;
  walletBalance!: number;
}

export type UpdateProfileDtoType = z.infer<typeof UpdateProfileDto>;
export type ChangePasswordDtoType = z.infer<typeof ChangePasswordDto>;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\interfaces\admin\IAdminController.ts ====

import { Request, Response } from "express";

export interface IAdminController {
  getAllUser(req: Request, res: Response): Promise<void>;
  getUser(req: Request, res: Response): Promise<void>;
  blockUser(req: Request, res: Response): Promise<void>;
  unblockUser(req: Request, res: Response): Promise<void>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\interfaces\admin\IAdminUser.interface.ts ====

export interface IAdminUserQuery {
  page: number;
  limit: number;
  sort: string;
  search: string;
}

export interface IUserResponse {
  _id: string;
  name: string;
  email: string;
  role: string;
  isBlocked: boolean;
}

export interface IPaginationUsers {
  users: IUserResponse[];
  total: number;
  totalPages: number;
  currentPage: number;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\interfaces\user\IauthController.ts ====

import express from "express";

export interface IAuthController {
  signup(req: express.Request, res: express.Response): Promise<void>;
  verifyOtp(req: express.Request, res: express.Response): Promise<void>;
  resendOtp(req: express.Request, res: express.Response): Promise<void>;
  login(req: express.Request, res: express.Response): Promise<void>;
  refresh(req: express.Request, res: express.Response): Promise<void>;
  forgetpassword(req: express.Request, res: express.Response): Promise<void>;
  verifyResetOtp(req: express.Request, res: express.Response): Promise<void>;
  resetPassword(req: express.Request, res: express.Response): Promise<void>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\interfaces\user\userRole.enum.ts ====

const UserRole = {
  USER: "user",
  ADMIN: "admin",
  PHOTOGRAPHER: "photographer",
} as const;
export type UserRoleType = (typeof UserRole)[keyof typeof UserRole];
export default UserRole;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\interfaces\user\userStatus.enum.ts ====

const UserStatus = {
  ACTIVE: "active",
  INACTIVE: "inactive",
  PENDING: "pending",
} as const;
export type UserStatusType = (typeof UserStatus)[keyof typeof UserStatus];
export default UserStatus;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\mappers\admin.mapper.ts ====

import type { AdminUserQueryDtoType } from "../dto/admin.dto.ts";
import type { IAdminUserQuery } from "../interfaces/admin/IAdminUser.interface.ts";

export class AdminMapper {
  static toQueryInput(dto: AdminUserQueryDtoType): IAdminUserQuery {
    return {
      page: dto.page,
      limit: dto.limit,
      sort: dto.sort,
      search: dto.search.trim(),
    };
  }

  static toUserResponse(user: any) {
    return {
      _id: user._id.toString(),
      name: user.name,
      email: user.email,
      role: user.role,
      isBlocked: user.isBlocked,
    };
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\mappers\auth.mapper.ts ====

import type { SignupDtoType } from "../dto/auth.dto.ts";
import type { IUser } from "../model/userModel.ts";

export class AuthMapper {
  static toUserFromSignup(dto: SignupDtoType): Partial<IUser> {
    return {
      name: dto.name.trim(),
      email: dto.email.toLowerCase(),
      password: dto.password,
      phone: dto.phone,
      role: "user",
      status: "active",
      isBlocked: false,
      walletBalance: 0,
    };
  }

  static sanitizeEmail(email: string): string {
    return email.toLowerCase().trim();
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\mappers\user.mapper.ts ====

import type { IUser } from "../model/userModel.ts";
import { UserResponseDto, UserProfileResponseDto, AuthResponseDto } from "../dto/user.dto.ts";

export class UserMapper {
  //this for admin

  static toUserResponse(user: IUser): UserResponseDto {
    const dto = new UserResponseDto();
    dto.id = user.id;
    dto.name = user.name;
    dto.email = user.email;
    dto.phone = user.phone;
    dto.role = user.role;
    dto.walletBalance = user.walletBalance;
    dto.isBlocked = user.isBlocked;
    return dto;
  }

  //this for user itsown profiles things
  static toProfileResponse(user: IUser): UserProfileResponseDto {
    const dto = new UserProfileResponseDto();
    dto.name = user.name;
    dto.email = user.email;
    dto.phone = user.phone;
    dto.role = user.role;
    dto.walletBalance = user.walletBalance;
    return dto;
  }

  //this for user auth login signup
  static toAuthResponse(user: IUser): AuthResponseDto["user"] {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
    };
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\authMiddleware.ts ====

import Jwt from "jsonwebtoken";
import type { Request, Response, NextFunction } from "express";
import dotenv from "dotenv";
dotenv.config();

interface JWTPayload {
  userId: string;
  role: string;
  email: string;
}

interface AuthRequest extends Request {
  user?: JWTPayload;
  role?: string;
  userId?: string;
}

export const verifyAccessToken = (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.cookies.accessToken;

    if (!token) {
      console.log(" No access token in cookies");
      return res.status(401).json({
        message: "Unauthorized - No token provided",
        redirectTo: "/auth/login",
      });
    }

    const decoded = Jwt.verify(token, process.env.ACCESS_TOKEN_SECRET!) as JWTPayload;

    req.user = decoded;
    req.role = decoded.role;
    req.userId = decoded.userId;

    next();
  } catch (error) {
    console.error(" Token verification error:", error);
    return res.status(403).json({
      message: "Invalid or expired token",
      redirectTo: "/auth/login",
    });
  }
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\checkTokenBlacklist.ts ====

import type { Request, Response, NextFunction } from "express";
import { tokenBlacklistService } from "../services/token/tokenBalcklist.service.ts";
import { HttpStatus } from "../constants/httpStatus.ts";
import { Messages } from "../constants/messages.ts";

interface AuthRequest extends Request {
  user?: {
    userId: string;
    role: string;
    email: string;
  };
}

export const checkTokenBlacklist = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    const token = req.cookies.accessToken;
    if (!token) {
      res.status(HttpStatus.UNAUTHORIZED).json({
        success: false,
        message: Messages.NO_TOKEN_PROVIDED,
      });
      return;
    }

    const isBlacklisted = await tokenBlacklistService.isBlackListed(token);

    if (isBlacklisted) {
      res.status(HttpStatus.UNAUTHORIZED).json({
        success: false,
        message: Messages.TOKEN_INVALID,
      });
      return;
    }

    next();
  } catch {
    res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: Messages.INTERNAL_ERROR,
    });
  }
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\errorMiddleware.ts ====

import type { Request, Response, NextFunction } from "express";
import logger from "../config/logger.ts";
import { AppError } from "../utils/AppError.ts";

export const errorHandler = (err: unknown, req: Request, res: Response, next: NextFunction) => {
  if (res.headersSent) {
    return next(err);
  }

  if (err instanceof AppError) {
    logger.warn(`AppError : ${err.message}`, {
      statusCode: err.statusCode,
      path: req.originalUrl,
      method: req.method,
    });

    return res.status(err.statusCode).json({
      success: false,
      message: err.message,
    });
  }

  if (err instanceof Error) {
    logger.error(`Unexpected Error: ${err.message}`, {
      stack: err.stack,
      path: req.originalUrl,
      method: req.method,
    });

    return res.status(500).json({
      success: false,
      message: "Internal Server Error",
    });
  }

  logger.error(`Non-standard error thrown: ${String(err)}`);

  return res.status(500).json({
    success: false,
    message: "Something went wrong",
  });
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\morganLogger.ts ====

import morgan from "morgan";
import { httpLogStream } from "../config/logger.ts";

const skip = () => process.env.NODE_ENV === "test";

const morganLogger = morgan(
  ":remote-addr :method :url :status :res[content-length] - :response-time ms",
  {
    stream: httpLogStream,
    skip,
  },
);

export default morganLogger;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\rateLimiter.middleware.ts ====

import rateLimit from "express-rate-limit";

export const AuthRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, //15
  max: 10,
  message: "Too many request from this IP, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
});


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\verifyAdmin.ts ====

import type { Request, Response, NextFunction } from "express";

interface AuthRequest extends Request {
  role?: string;
  user?: any;
}

export const verifyAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (!req.role) {
    console.log(" No role found");
    return res.status(401).json({
      message: "Authentication required",
      redirectTo: "/auth/login",
    });
  }

  if (req.role !== "admin") {
    console.log(" user is not admin, role:", req.role);
    return res.status(403).json({
      message: "Access denied. Admins only.",
      redirectTo: "/auth/login",
    });
  }

  console.log(" admin verified successfully");
  next();
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\middleware\verifyUserBlock.ts ====

import type { Request, Response, NextFunction } from "express";
import { User } from "../model/userModel.ts";
import { Messages } from "../constants/messages.ts";
import { HttpStatus } from "../constants/httpStatus.ts";

interface AuthRequest extends Request {
  userId?: string;
  user?: any;
}

export const verifyUserNotBlocked = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    if (!req.userId) {
      res.status(HttpStatus.UNAUTHORIZED).json({
        success: false,
        message: "Authentication required",
        redirectTo: "/auth/login",
      });
      return;
    }

    const user = await User.findById(req.userId).select("isBlocked").lean();

    if (!user) {
      res.status(HttpStatus.NOT_FOUND).json({
        success: false,
        message: Messages.USER_NOTFOUND,
        redirectTo: "/auth/login",
      });
      return;
    }

    if (user.isBlocked) {
      res.clearCookie("accessToken");
      res.clearCookie("refreshToken");

      res.status(HttpStatus.FORBIDDEN).json({
        success: false,
        message: Messages.USER_BLOCKED,
        redirectTo: "/auth/login",
      });
      return;
    }

    next();
  } catch (error) {
    console.error("Error checking user blocked status:", error);
    res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: Messages.INTERNAL_ERROR,
    });
  }
};


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\model\userModel.ts ====

import mongoose, { Document, Schema } from "mongoose";
import bcrypt from "bcrypt";
import type { UserRoleType } from "../interfaces/user/userRole.enum.ts";
import UserRole from "../interfaces/user/userRole.enum.ts";
import type { UserStatusType } from "../interfaces/user/userStatus.enum.ts";
import UserStatus from "../interfaces/user/userStatus.enum.ts";

export interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  phone: string;
  role: UserRoleType;
  status: UserStatusType;
  isBlocked: boolean;
  walletBalance: number;
  comparePassword(candidate: string): Promise<boolean>;
}

const userSchema = new Schema<IUser>(
  {
    name: { type: String, required: true, trim: true },
    email: { type: String, required: true, unique: true, lowercase: true },
    password: { type: String, required: true, minlength: 8 },
    phone: { type: String, required: true },
    role: {
      type: String,
      enum: Object.values(UserRole),
      default: UserRole.USER,
    },
    status: {
      type: String,
      enum: Object.values(UserStatus),
      default: UserStatus.ACTIVE,
    },
    isBlocked: { type: Boolean, default: false },
    walletBalance: { type: Number, default: 0 },
  },
  { timestamps: true },
);

userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

userSchema.methods.comparePassword = async function (candidate: string) {
  return bcrypt.compare(candidate, this.password);
};

export const User = mongoose.model<IUser>("User", userSchema);


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\repositories\base\BaseRepository.ts ====

import type { Model, Document } from "mongoose";

export abstract class BaseRepository<T extends Document> {
  protected readonly _model: Model<T>;

  constructor(model: Model<T>) {
    this._model = model;
  }

  async create(data: Partial<T>): Promise<T> {
    return await this._model.create(data);
  }

  async findById(id: string): Promise<T | null> {
    return await this._model.findById(id).exec();
  }

  async findOne(query: Partial<T>): Promise<T | null> {
    const data = await this._model.findOne(query as any).exec();

    return data;
  }

  async update(id: string, data: Partial<T>): Promise<T | null> {
    return await this._model.findByIdAndUpdate(id, data, { new: true }).exec();
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\repositories\implementaion\admin\admin.repository.ts ====

import { User } from "../../../model/userModel.ts";
import type { IAdminRepository } from "../../interface/IAdminReporitory.ts";
import type {
  IUserResponse,
  IAdminUserQuery,
  IPaginationUsers,
} from "../../../interfaces/admin/IAdminUser.interface.ts";
import { AdminMapper } from "../../../mappers/admin.mapper.ts";

export class AdminRepository implements IAdminRepository {
  async getAllUser(query: IAdminUserQuery): Promise<IPaginationUsers> {
    const { limit, page, search, sort } = query;
    const skip = (page - 1) * limit;
    const roleFilter = { role: { $ne: "admin" } }; // only user
    const searchQuery = search
      ? { ...roleFilter, name: { $regex: search, $options: "i" } }
      : roleFilter;

    const users = await User.find(searchQuery)
      .sort({ [sort]: 1 })
      .skip(skip)
      .limit(limit)
      .lean();

    const formatedUser: IUserResponse[] = users.map(AdminMapper.toUserResponse);

    const total = await User.countDocuments(searchQuery);

    return {
      users: formatedUser,
      total,
      currentPage: page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getUser(userId: string): Promise<IUserResponse | null> {
    const user = await User.findById(userId).lean();
    if (!user) return null;

    return {
      _id: user._id.toString(),
      name: user.name,
      email: user.email,
      role: user.role,
      isBlocked: user.isBlocked,
    };
  }

  async blockUser(userId: string): Promise<IUserResponse | null> {
    const user = await User.findByIdAndUpdate(userId, { isBlocked: true }, { new: true }).lean();
    if (!user) return null;

    return {
      _id: user._id.toString(),
      name: user.name,
      email: user.email,
      role: user.role,
      isBlocked: user.isBlocked,
    };
  }

  async unblockUser(userId: string): Promise<IUserResponse | null> {
    const user = await User.findByIdAndUpdate(userId, { isBlocked: false }, { new: true }).lean();
    if (!user) return null;

    return {
      _id: user._id.toString(),
      name: user.name,
      email: user.email,
      role: user.role,
      isBlocked: user.isBlocked,
    };
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\repositories\implementaion\user\user.repositery.ts ====

import { User } from "../../../model/userModel.ts";
import type { IUser } from "../../../model/userModel.ts";
import type { IUserRepository } from "../../interface/IUserRespository.ts";
import { BaseRepository } from "../../base/BaseRepository.ts";

export class UserRepository extends BaseRepository<IUser> implements IUserRepository {
  constructor() {
    super(User);
  }

  async findByEmail(email: string): Promise<IUser | null> {
    const data = await this.findOne({ email: email.toLowerCase().trim() } as Partial<IUser>);
    return data;
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\repositories\interface\IAdminReporitory.ts ====

import type {
  IPaginationUsers,
  IAdminUserQuery,
  IUserResponse,
} from "../../interfaces/admin/IAdminUser.interface.ts";

export interface IAdminRepository {
  getAllUser(query: IAdminUserQuery): Promise<IPaginationUsers>;
  getUser(userId: string): Promise<IUserResponse | null>;
  blockUser(userId: string): Promise<IUserResponse | null>;
  unblockUser(userId: string): Promise<IUserResponse | null>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\repositories\interface\IUserRespository.ts ====

import type { IUser } from "../../model/userModel";

export interface IUserRepository {
  create(data: Partial<IUser>): Promise<IUser>;
  findByEmail(email: string): Promise<IUser | null>;
  findById(_id: string): Promise<IUser | null>;
  update(_id: string, data: Partial<IUser>): Promise<IUser | null>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\routes\admin.route.ts ====

import { Router } from "express";
import { verifyAdmin } from "../middleware/verifyAdmin.ts";
import { verifyAccessToken } from "../middleware/authMiddleware.ts";
import { ROUTES } from "../constants/routes.ts";
import { container } from "../di/container.ts";

const route = Router();
const adminController = container.adminController;

route.get(ROUTES.V1.ADMIN.USERS, verifyAccessToken, verifyAdmin, adminController.getAllUser);
route.get(ROUTES.V1.ADMIN.USER_BY_ID, verifyAccessToken, verifyAdmin, adminController.getUser);
route.patch(ROUTES.V1.ADMIN.BLOCK, verifyAccessToken, verifyAdmin, adminController.blockUser);
route.patch(ROUTES.V1.ADMIN.UNBLOCK, verifyAccessToken, verifyAdmin, adminController.unblockUser);

export default route;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\routes\auth.routes.ts ====

import { Router } from "express";
import { AuthRateLimiter } from "../middleware/rateLimiter.middleware.ts";
import { ROUTES } from "../constants/routes.ts";
import { checkTokenBlacklist } from "../middleware/checkTokenBlacklist.ts";
import { container } from "../di/container.ts";

const router = Router();
const authController = container.authController;

router.post(ROUTES.V1.AUTH.SIGNUP, AuthRateLimiter, authController.signup);
router.post(ROUTES.V1.AUTH.VERIFY_OTP, AuthRateLimiter, authController.verifyOtp);
router.post(ROUTES.V1.AUTH.RESEND_OTP, AuthRateLimiter, authController.resendOtp);
router.post(ROUTES.V1.AUTH.LOGIN,checkTokenBlacklist, authController.login);
router.post(ROUTES.V1.AUTH.REFRESH, AuthRateLimiter, authController.refresh);
router.post(ROUTES.V1.AUTH.LOGOUT, checkTokenBlacklist, authController.logout);
router.post(ROUTES.V1.AUTH.FORGOT_PASSWORD, AuthRateLimiter, authController.forgetpassword);
router.post(ROUTES.V1.AUTH.VERIFY_RESET_OTP, AuthRateLimiter, authController.verifyResetOtp);
router.post(ROUTES.V1.AUTH.RESET_PASSWORD, AuthRateLimiter, authController.resetPassword);

export default router;


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\server.ts ====

import dotenv from "dotenv";
dotenv.config();

import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { connectDB } from "./config/db.ts";
import swaggerUi from "swagger-ui-express";
import { swaggerSpec } from "./config/swagger.ts";
import morganLogger from "./middleware/morganLogger.ts";
import authRoutes from "./routes/auth.routes.ts";
import adminRoute from "./routes/admin.route.ts";
import { errorHandler } from "./middleware/errorMiddleware.ts";
import { ROUTES } from "./constants/routes.ts";

const app = express();
const PORT = 5000;

app.use(morganLogger);
app.use(cookieParser());
app.use(express.urlencoded({ extended: true }));
app.use(
  cors({
    origin: "http://localhost:5173",
    credentials: true,
  }),
);
app.use(express.json());
connectDB();

app.use(ROUTES.V1.AUTH.BASE, authRoutes);
app.use(ROUTES.V1.ADMIN.BASE, adminRoute);

app.use("/api-doc", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

app.use(errorHandler);

app.get("/", (req, res) => {
  res.send(" Backend server is running successfully!");
});

app.listen(PORT, async () => {
  console.log(`‚úÖServer is running at http://localhost:${PORT}`);
});


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\admin\implementaion\admin.service.ts ====

import type { IAdminService } from "../interface/IAdminService.ts";
import type {
  IAdminUserQuery,
  IPaginationUsers,
  IUserResponse,
} from "../../../interfaces/admin/IAdminUser.interface.ts";
import type { IAdminRepository } from "../../../repositories/interface/IAdminReporitory.ts";

export class AdminServices implements IAdminService {
  private adminRepository: IAdminRepository;

  constructor(adminRepository: IAdminRepository) {
    this.adminRepository = adminRepository;
  }

  getAllUser(query: IAdminUserQuery): Promise<IPaginationUsers> {
    return this.adminRepository.getAllUser(query);
  }

  getUser(userId: string): Promise<IUserResponse | null> {
    return this.adminRepository.getUser(userId);
  }

  async blockUser(userId: string): Promise<IUserResponse | null> {
    return this.adminRepository.blockUser(userId);
  }

  async unblockUser(userId: string): Promise<IUserResponse | null> {
    return this.adminRepository.unblockUser(userId);
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\admin\interface\IAdminService.ts ====

import type {
  IAdminUserQuery,
  IPaginationUsers,
  IUserResponse,
} from "../../../interfaces/admin/IAdminUser.interface";

export interface IAdminService {
  getAllUser(query: IAdminUserQuery): Promise<IPaginationUsers>;
  getUser(userId: string): Promise<IUserResponse | null>;
  blockUser(userId: string): Promise<IUserResponse | null>;
  unblockUser(userId: string): Promise<IUserResponse | null>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\token\interface.ts ====

export interface ITokenBlackListService {
  addToBlackList(token: string, expiryIn: number): Promise<void>;
  isBlackListed(token: string): Promise<boolean>;
  removeFromBlacklist(token: string): Promise<void>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\token\tokenBalcklist.service.ts ====

import redisClient from "../../config/redis.ts";
import logger from "../../config/logger.ts";
import type { ITokenBlackListService } from "./interface.ts";

export class TokenBlacklistService implements ITokenBlackListService {
  private readonly _Prefix = "blacklist:";

  async addToBlackList(token: string, expiryIn: number): Promise<void> {
    try {
      const key = this._Prefix + token;
      await redisClient.setEx(key, expiryIn, "true");
      logger.info("Token added tp blacklist", { tokenPrifix: token.substring(0, 10) });
    } catch (error) {
      logger.error("failed to add token to blackList", { error });
      throw new Error("Failed tp blacklist Token");
    }
  }

  async isBlackListed(token: string): Promise<boolean> {
    try {
      const key = this._Prefix + token;
      const result = await redisClient.get(key);
      return result === "true";
    } catch (error) {
      logger.error("Failed tp check token blacklist", { error });
      return false;
    }
  }

  async removeFromBlacklist(token: string): Promise<void> {
    try {
      const key = this._Prefix + token;
      await redisClient.del(key);
      logger.info("Token removed balcklist");
    } catch (error) {
      logger.error("Failed to remove token from balckList", error);
    }
  }
}

export const tokenBlacklistService = new TokenBlacklistService();


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\auth\auth.servise.ts ====

import type { IUser } from "model/userModel.ts";
import type { IUserRepository } from "../../../repositories/interface/IUserRespository.ts";
import redisClient from "../../../config/redis.ts";
import { createAccessToken, createRefreshToken } from "../../../utils/token.ts";
import dotenv from "dotenv";
dotenv.config();
import type { IAuthService } from "./IAuthService.ts";
import type { IEmailService } from "../email/IEmailServise.ts";
import type { IOtpService } from "../otp/IOtpService.ts";
import type {
  ForgetPasswordDtoType,
  LoginDtoType,
  ResendOtpDtoType,
  ResetPasswordDtoType,
  SignupDtoType,
  VerifyOtpDtoType,
} from "../../../dto/auth.dto.ts";
import { Messages } from "../../../constants/messages.ts";
import { AuthMapper } from "../../../mappers/auth.mapper.ts";
import bcrypt from "bcrypt";
import { tokenBlacklistService } from "../../token/tokenBalcklist.service.ts";
import jwt from "jsonwebtoken";
import logger from "../../../config/logger.ts";

export class AuthService implements IAuthService {
  private readonly _userRepo: IUserRepository;
  private readonly _emailService: IEmailService;
  private readonly _otpService: IOtpService;

  constructor(useRepo: IUserRepository, emailRepo: IEmailService, otpRepo: IOtpService) {
    this._userRepo = useRepo;
    this._emailService = emailRepo;
    this._otpService = otpRepo;
  }

  async signup(data: SignupDtoType) {
    const existingUser = await this._userRepo.findByEmail(data.email);
    if (existingUser) throw new Error(Messages.USER_EXISTS);

    const otp = this._otpService.generateOtp();
    console.log("signup OTP:", otp);
    const expiry = this._otpService.getOtpExpire();

    const userData = AuthMapper.toUserFromSignup(data);

    await redisClient.setEx(
      `otp:${data.email}`,
      parseInt(process.env.OTP_EXPIRY_SECONDS || "120", 10),
      JSON.stringify({ ...userData, otp, expiry }),
    );

    await this._emailService.sendOtp(data.email, otp, data.name);

    return { message: Messages.OTP_SENT };
  }

  async verifyOtp(data: VerifyOtpDtoType) {
    const cached = await redisClient.get(`otp:${data.email}`);

    // console.log("cached valure",cached);

    if (!cached) throw new Error(Messages.INVALID_OTP);

    const payload = JSON.parse(cached);
    // ("payload :",payload)
    // (typeof data.email)
    const isValid = this._otpService.isOtpValidate(payload.otp, data.otp, payload.expiry);
    if (!isValid) throw new Error(Messages.INVALID_OTP);

    const user = await this._userRepo.create(payload);

    await redisClient.del(`otp:${data.email}`);
    await this._emailService.sendWelcomeEmail(user.email, user.name);

    return this._issueTokens(user);
  }

  async resendOtp(data: ResendOtpDtoType) {
    const cached = await redisClient.get(`otp:${data.email}`);
    if (!cached) throw new Error(Messages.USER_EXISTS);

    const payload = JSON.parse(cached);
    const newOtp = this._otpService.generateOtp();

    await redisClient.setEx(
      `otp:${data.email}`,
      Number(process.env.OTP_EXPIRY_SECONDS),
      JSON.stringify({ ...payload, otp: newOtp }),
    );
    await this._emailService.sendOtp(data.email, newOtp, payload.name);

    return { message: Messages.OTP_SENT };
  }

  async login(data: LoginDtoType) {
    const user = await this._userRepo.findByEmail(data.email);
    if (!user || !(await user.comparePassword(data.password)))
      throw new Error(Messages.INVALID_CREDENTIALS);
    if (user.isBlocked) throw new Error(Messages.USER_BLOCKED);

    return this._issueTokens(user);
  }

  async refresh(refreshToken: string) {
    const userId = await redisClient.get(`rt:${refreshToken}`);
    if (!userId) throw new Error(Messages.INVALID_REFRESH_TOKEN);

    const user = await this._userRepo.findById(userId);
    if (!user || user.isBlocked) throw new Error(Messages.USER_BLOCKED);

    await redisClient.del(`rt:${refreshToken}`);
    return this._issueTokens(user);
  }

  async logout(refreshToken: string) {
    try {
      const decoded = jwt.decode(refreshToken) as { exp?: number } | null;
      const expiresIn = decoded?.exp
        ? decoded.exp - Math.floor(Date.now() / 1000)
        : 7 * 24 * 60 * 60;

      await tokenBlacklistService.addToBlackList(refreshToken, expiresIn);
      await redisClient.del(`rt:${refreshToken}`);
    } catch (error) {
      logger.error("logger error", { error });
      throw new Error("Logout failed");
    }
  }

  async forgetPassword(data: ForgetPasswordDtoType): Promise<{ message: string }> {
    const user = await this._userRepo.findByEmail(data.email.trim());

    if (!user) {
      return { message: Messages.FORGET_PASSWORD_SENT };
    }

    const otp = this._otpService.generateOtp();
    const expiry = this._otpService.getOtpExpire();
    console.log("Generated reset OTP:", otp);

    await redisClient.setEx(
      `fp:${data.email.toLowerCase().trim()}`,
      300,
      JSON.stringify({ otp, expiry }),
    );
    await this._emailService.sendResetCode(data.email, otp, user.name);

    return { message: Messages.FORGET_PASSWORD_SENT };
  }

  async verifyResetOtp(data: VerifyOtpDtoType): Promise<{ message: string }> {
    const cached = await redisClient.get(`fp:${data.email.toLowerCase().trim()}`);
    if (!cached) throw new Error(Messages.INVALID_RESET_OTP);

    const payload = JSON.parse(cached);
    const isValid = this._otpService.isOtpValidate(payload.otp, data.otp, payload.expiry);
    if (!isValid) throw new Error(Messages.INVALID_RESET_OTP);

    await redisClient.setEx(`fp:verified:${data.email}`, 600, "true"); // means 10 minute
    await redisClient.del(`fp:${data.email}`);

    return { message: Messages.RESET_OTP_VERIFIED };
  }

  async resetPassword(data: ResetPasswordDtoType): Promise<{ message: string }> {
    const isVerified = await redisClient.get(`fp:verified:${data.email.toLowerCase().trim()}`);
    if (!isVerified) throw new Error(Messages.VERIFY_FIRST);

    const user = await this._userRepo.findByEmail(data.email.trim());
    if (!user) throw new Error(Messages.USER_NOTFOUND);

    const hashed = await bcrypt.hash(data.newPassword, 10);
    await this._userRepo.update(user.id!.toString(), { password: hashed });

    await redisClient.del(`fp:verified:${data.email.toLowerCase().trim()}`);
    return { message: Messages.PASSWORD_RESET_SUCCESS };
  }

  private _issueTokens(user: IUser) {
    const accessToken = createAccessToken(user._id!.toString(), user.email, user.role);
    const refreshToken = createRefreshToken(user._id!.toString(), user.email, user.role);
    redisClient.setEx(
      `rt:${refreshToken}`,
      Number(process.env.REFRESH_TOKEN_MAX_AGE),
      user._id!.toString(),
    );
    return { accessToken, refreshToken, user };
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\auth\IAuthService.ts ====

import type {
  SignupDtoType,
  LoginDtoType,
  VerifyOtpDtoType,
  ResendOtpDtoType,
  ForgetPasswordDtoType,
  ResetPasswordDtoType,
} from "../../../dto/auth.dto.ts";
import type { IUser } from "../../../model/userModel.ts";

export interface IAuthService {
  signup(data: SignupDtoType): Promise<{ message: string }>;
  verifyOtp(
    data: VerifyOtpDtoType,
  ): Promise<{ accessToken: string; refreshToken: string; user: IUser }>;
  resendOtp(data: ResendOtpDtoType): Promise<{ message: string }>;
  login(data: LoginDtoType): Promise<{ accessToken: string; refreshToken: string; user: IUser }>;
  refresh(
    refreshToken: string,
  ): Promise<{ accessToken: string; refreshToken: string; user: IUser }>;
  logout(refreshToken: string): Promise<void>;
  forgetPassword(data: ForgetPasswordDtoType): Promise<{ message: string }>;
  verifyResetOtp(data: VerifyOtpDtoType): Promise<{ message: string }>;
  resetPassword(data: ResetPasswordDtoType): Promise<{ message: string }>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\email\IEmailServise.ts ====

export interface IEmailService {
  sendOtp(email: string, otp: string, name: string): Promise<void>;
  sendWelcomeEmail(email: string, name: string): Promise<void>;
  sendResetCode(email: string, otp: string, name: string): Promise<void>;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\email\nodemailer.service.ts ====

import type { IEmailService } from "./IEmailServise.ts";

import { mailTransport } from "../../../config/email.ts";

export class NodeMailerService implements IEmailService {
  async sendOtp(email: string, otp: string, name: string): Promise<void> {
    try {
      console.log("email from nodemailer", email);
      const mailOptions = {
        from: `"photobook app" <${process.env.SMTP_USER}>`,
        to: email,
        subject: "your PHTOT-BOOK verification code",
        html: this.getotpEmailTemplate(name, otp),
      };

      await mailTransport.sendMail(mailOptions);
      console.log(`otp eamil sent successfulyy to ${email}`);
      console.log(`otp ${otp}`);
    } catch (error: any) {
      console.log("erron in otp sent");
      throw new Error("Failed to send verification eamil. Please try again.", error);
    }
  }

  async sendWelcomeEmail(email: string, name: string): Promise<void> {
    try {
      const mailOptions = {
        from: `"PhotoBook Team" <${process.env.SMTP_USER}>`,
        to: email,
        subject: "Welcome to Photo-Book",
        html: this.getWelcomeEmailTemplate(name),
      };
      await mailTransport.sendMail(mailOptions);
      console.log(` Welcome email sent to ${email}`);
    } catch (error: any) {
      console.error(" Failed to send welcome email:", error.message);
    }
  }

  async sendResetCode(email: string, otp: string, name: string): Promise<void> {
    const html = `
    <h2>Hi ${name},</h2>
    <p>We received a request to reset your PhotoBook password.</p>
    <div style="background:#f0f0f0;padding:20px;text-align:center;font-size:32px;letter-spacing:8px;">
      <strong>${otp}</strong>
    </div>
    <p>This code expires in <strong>5 minutes</strong>.</p>
    <p>If you didn't request this, ignore this email.</p>
  `;
    await mailTransport.sendMail({
      from: `"PhotoBook" <${process.env.SMTP_USER}>`,
      to: email,
      subject: "Password Reset Code",
      html,
    });
  }

  private getotpEmailTemplate(name: string, otp: string): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
          body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 40px 20px;
          }
          .container { 
            background: white; 
            max-width: 560px;
            margin: 0 auto;
            padding: 40px 30px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          }
          .header {
            text-align: center;
            margin-bottom: 30px;
          }
          .header h1 {
            color: #667eea;
            margin: 0;
            font-size: 28px;
          }
          .otp-box { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
            font-size: 36px;
            font-weight: bold;
            letter-spacing: 8px;
            border-radius: 12px;
            margin: 30px 0;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
          }
          .content {
            color: #333;
            line-height: 1.6;
          }
          .footer { 
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            font-size: 13px;
            color: #999;
          }
          .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            color: #856404;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>üì∏ PhotoBook</h1>
          </div>
          <div class="content">
            <h2>Hi ${name},</h2>
            <p>Welcome to <strong>PhotoBook</strong>! To complete your registration, please verify your email address using the code below:</p>
            
            <div class="otp-box">${otp}</div>
            
            <p>This verification code is valid for <strong>2 minutes</strong>.</p>
            
            <div class="warning">
              ‚ö†Ô∏è <strong>Security Notice:</strong> If you didn't create this account, please ignore this email.
            </div>
          </div>
          <div class="footer">
            <p>¬© 2025 PhotoBook. All rights reserved.</p>
            <p>This is an automated message, please do not reply.</p>
          </div>
        </div>
      </body>
      </html>
    `;
  }

  private getWelcomeEmailTemplate(name: string): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 40px 20px;
          }
          .container { 
            background: white; 
            max-width: 560px;
            margin: 0 auto;
            padding: 40px 30px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          }
          .celebration {
            text-align: center;
            font-size: 48px;
            margin: 20px 0;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="celebration">üéâ</div>
          <h1 style="color: #667eea; text-align: center;">Welcome to PhotoBook!</h1>
          <p>Hi <strong>${name}</strong>,</p>
          <p>Your account has been successfully verified! You can now:</p>
          <ul>
            <li>üì∑ Upload and organize your favorite photos</li>
            <li>üìÅ Create beautiful photo albums</li>
            <li>ü§ù Share memories with friends and family</li>
          </ul>
          <p style="text-align: center; margin: 30px 0;">
            <a href="${process.env.FRONTEND_URL || "http://localhost:5173"}" 
ends and family</li>
          </ul>
          <p style="text-align: center; margin: 30px 0;">
            <a href="${process.env.FRONTEND_URL || "http://localhost:5173"}" 
               style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                      color: white; 
                      padding: 12px 30px; 
                      text-decoration: none; 
                      border-radius: 6px;
                      display: inline-block;">
              Get Started ‚Üí
            </a>
          </p>
        </div>
      </body>
      </html>
    `;
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\otp\IOtpService.ts ====

export interface IOtpService {
  generateOtp(): string;
  getOtpExpire(): Date;
  isOtpValidate(sotredOtp: string, providedOtp: string, expiryDate: Date | undefined): boolean;
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\otp\otp.service.ts ====

import { randomInt } from "crypto";
import type { IOtpService } from "../otp/IOtpService";

export class Otpservice implements IOtpService {
  private readonly OTP_LENGTH = 6;
  private readonly OTP_EXPIRY_TIME = 2;

  generateOtp(): string {
    return randomInt(100000, 999999).toString();
  }
  getOtpExpire(): Date {
    return new Date(Date.now() + this.OTP_EXPIRY_TIME * 60 * 1000);
  }

  isOtpValidate(storedOtp: string, providedOtp: string, expiry?: Date): boolean {
    if (!storedOtp || !providedOtp) return false;
    if (providedOtp.length !== this.OTP_LENGTH) return false;
    if (storedOtp !== providedOtp) return false;
    if (expiry && expiry < new Date()) return false;
    return true;
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\utils\pagination.ts ====

export interface PaginationParams {
  page: number;
  limit: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    totalPages: number;
    currentPage: number;
    limit: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export class PaginationHelper {
  static calculate(page: number, limit: number) {
    const skip = (page - 1) * limit;
    return { skip, limit };
  }

  static buildResponse<T>(
    data: T[],
    total: number,
    page: number,
    limit: number,
  ): PaginatedResponse<T> {
    const totalPages = Math.ceil(total / limit);
    return {
      data,
      pagination: {
        total,
        totalPages,
        currentPage: page,
        limit,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      },
    };
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\services\user\utils\response.ts ====

import { Response } from "express";
import { HttpStatus } from "../../../constants/httpStatus.ts";

export class ApiResponse {
  static success<T>(
    res: Response,
    data: T,
    message: string = "Success",
    status: HttpStatus = HttpStatus.OK,
  ) {
    return res.status(status).json({
      success: true,
      message,
      data,
    });
  }

  static error(
    res: Response,
    message: string,
    status: HttpStatus = HttpStatus.INTERNAL_SERVER_ERROR,
  ) {
    return res.status(status).json({
      success: false,
      message,
    });
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\utils\AppError.ts ====

export class AppError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(message: string, statusCode: number, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    Error.captureStackTrace(this, this.constructor);
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\utils\mapper.ts ====



==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\utils\response.ts ====

import type { Response } from "express";
import { HttpStatus } from "../constants/httpStatus.ts";

export class ApiResponse {
  static success<T>(
    res: Response,
    data: T,
    message: string = "Success",
    status: HttpStatus = HttpStatus.OK,
  ) {
    return res.status(status).json({
      success: true,
      message,
      data,
    });
  }

  static error(
    res: Response,
    message: string,
    status: HttpStatus = HttpStatus.INTERNAL_SERVER_ERROR,
  ) {
    return res.status(status).json({
      success: false,
      message,
    });
  }
}


==== C:\Users\DELL\OneDrive\Desktop\completed Projects\Photo-book\backend\src\utils\token.ts ====

import jwt from "jsonwebtoken";
import dotenv from "dotenv";
dotenv.config();

export const createAccessToken = (userId: string, email: string, role: string) => {
  if (!process.env.ACCESS_TOKEN_SECRET) {
    throw new Error("REFRESH_TOKEN_SECRET is not defined");
  }
  return jwt.sign({ userId: userId, email: email, role: role }, process.env.ACCESS_TOKEN_SECRET, {
    expiresIn: "15m",
  });
};

export const createRefreshToken = (userId: string, email: string, role: string) => {
  if (!process.env.REFRESH_TOKEN_SECRET) {
    throw new Error("REFRESH_TOKEN_SECRET is not defined");
  }
  return jwt.sign({ userId: userId, email: email, role: role }, process.env.REFRESH_TOKEN_SECRET, {
    expiresIn: "7d",
  });
};
